import { ProcedureType } from '../router';
import { TRPCError } from '../TRPCError';
export declare const middlewareMarker: unique symbol;
interface MiddlewareResultBase<TContext> {
    /**
     * All middlewares should pass through their `next()`'s output.
     * Requiring this marker makes sure that can't be forgotten at compile-time.
     */
    readonly marker: typeof middlewareMarker;
    ctx: TContext;
}
interface MiddlewareOKResult<TContext> extends MiddlewareResultBase<TContext> {
    ok: true;
    data: unknown;
}
interface MiddlewareErrorResult<TContext> extends MiddlewareResultBase<TContext> {
    ok: false;
    error: TRPCError;
}
export declare type MiddlewareResult<TContext> = MiddlewareOKResult<TContext> | MiddlewareErrorResult<TContext>;
export declare type MiddlewareFunction<TInputContext, TContext> = (opts: {
    ctx: TInputContext;
    type: ProcedureType;
    path: string;
    rawInput: unknown;
    next: {
        (): Promise<MiddlewareResult<TInputContext>>;
        <T>(opts: {
            ctx: T;
        }): Promise<MiddlewareResult<T>>;
    };
}) => Promise<MiddlewareResult<TContext>>;
export {};
//# sourceMappingURL=middlewares.d.ts.map