import { ProcedureType } from '../router';
import { MiddlewareFunction } from './middlewares';
export declare type ProcedureInputParserZodEsque<TInput, TParsedInput> = {
    _input: TInput;
    _output: TParsedInput;
};
export declare type ProcedureInputParserMyZodEsque<TInput> = {
    parse: (input: any) => TInput;
};
export declare type ProcedureInputParserSuperstructEsque<TInput> = {
    create: (input: unknown) => TInput;
};
export declare type ProcedureInputParserCustomValidatorEsque<TInput> = (input: unknown) => TInput | Promise<TInput>;
export declare type ProcedureInputParserYupEsque<TInput> = {
    validateSync: (input: unknown) => TInput;
};
export declare type ProcedureInputParser<TInput> = ProcedureInputParserYupEsque<TInput> | ProcedureInputParserSuperstructEsque<TInput> | ProcedureInputParserCustomValidatorEsque<TInput> | ProcedureInputParserMyZodEsque<TInput>;
export declare type ProcedureInputParserWithInputOutput<TInput, TParsedInput> = ProcedureInputParserZodEsque<TInput, TParsedInput>;
export declare type ProcedureResolver<TContext, TParsedInput, TOutput> = (opts: {
    ctx: TContext;
    input: TParsedInput;
    type: ProcedureType;
}) => Promise<TOutput> | TOutput;
interface ProcedureOptions<TContext, TParsedInput, TOutput> {
    middlewares: Array<MiddlewareFunction<any, any>>;
    resolver: ProcedureResolver<TContext, TParsedInput, TOutput>;
    inputParser: ProcedureInputParser<TParsedInput>;
}
/**
 * @internal
 */
export interface ProcedureCallOptions<TContext> {
    ctx: TContext;
    rawInput: unknown;
    path: string;
    type: ProcedureType;
}
/**
 * @internal
 */
export declare class Procedure<TInputContext, TContext, TInput, TParsedInput, TOutput> {
    private middlewares;
    private resolver;
    private readonly inputParser;
    private parse;
    constructor(opts: ProcedureOptions<TContext, TParsedInput, TOutput>);
    private parseInput;
    /**
     * Trigger middlewares in order, parse raw input & call resolver
     * @internal
     */
    call(opts: ProcedureCallOptions<TInputContext>): Promise<TOutput>;
    /**
     * Create new procedure with passed middlewares
     * @param middlewares
     */
    inheritMiddlewares(middlewares: MiddlewareFunction<TInputContext, TContext>[]): this;
}
export declare type CreateProcedureWithInput<TContext, TInput, TParsedInput, TOutput> = {
    input: ProcedureInputParser<TInput>;
    resolve: ProcedureResolver<TContext, TParsedInput, TOutput>;
};
export declare type CreateProcedureWithInputOutputParser<TContext, TInput, TParsedInput, TOutput> = {
    input: ProcedureInputParserWithInputOutput<TInput, TParsedInput>;
    resolve: ProcedureResolver<TContext, TParsedInput, TOutput>;
};
export declare type CreateProcedureWithoutInput<TContext, TOutput> = {
    resolve: ProcedureResolver<TContext, undefined, TOutput>;
};
export declare type CreateProcedureOptions<TContext, TInput = undefined, TParsedInput = undefined, TOutput = undefined> = CreateProcedureWithInput<TContext, TInput, TParsedInput, TOutput> | CreateProcedureWithInputOutputParser<TContext, TInput, TParsedInput, TOutput> | CreateProcedureWithoutInput<TContext, TOutput>;
export declare function createProcedure<TContext, TInput, TParsedInput, TOutput>(opts: CreateProcedureOptions<TContext, TInput, TParsedInput, TOutput>): Procedure<unknown, TContext, TInput, TParsedInput, TOutput>;
export declare type inferProcedureFromOptions<TInputContext, TOptions extends CreateProcedureOptions<any, any, any, any>> = TOptions extends CreateProcedureOptions<infer TContext, infer TInput, infer TParsedInput, infer TOutput> ? Procedure<TInputContext, TContext, unknown extends TInput ? undefined : TInput, unknown extends TParsedInput ? undefined : TParsedInput, TOutput> : never;
export {};
//# sourceMappingURL=procedure.d.ts.map