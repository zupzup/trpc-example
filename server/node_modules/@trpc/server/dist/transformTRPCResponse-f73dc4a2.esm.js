async function callProcedure(opts) {
  const {
    type,
    path,
    input
  } = opts;
  const caller = opts.router.createCaller(opts.ctx);

  if (type === 'query') {
    return caller.query(path, input);
  }

  if (type === 'mutation') {
    return caller.mutation(path, input);
  }

  if (type === 'subscription') {
    const sub = await caller.subscription(path, input);
    return sub;
  }
  /* istanbul ignore next */


  throw new Error(`Unknown procedure type ${type}`);
}

class TRPCError extends Error {
  /**
   * @deprecated use `cause`
   */
  constructor(opts) {
    var _opts$cause, _opts$message;

    const cause = (_opts$cause = opts.cause) !== null && _opts$cause !== void 0 ? _opts$cause : opts.originalError;
    const code = opts.code;
    const message = (_opts$message = opts.message) !== null && _opts$message !== void 0 ? _opts$message : getMessageFromUnkownError(cause, code); // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore https://github.com/tc39/proposal-error-cause

    super(message, {
      cause
    });
    this.originalError = void 0;
    this.cause = void 0;
    this.code = void 0;
    this.code = code;
    this.cause = this.originalError = cause;
    this.name = 'TRPCError';
    Object.setPrototypeOf(this, new.target.prototype);
  }

}

function getMessageFromUnkownError(err, fallback) {
  if (typeof err === 'string') {
    return err;
  }

  if (err instanceof Error && typeof err.message === 'string') {
    return err.message;
  }

  return fallback;
}
function getErrorFromUnknown(cause) {
  // this should ideally be an `instanceof TRPCError` but for some reason that isn't working
  // ref https://github.com/trpc/trpc/issues/331
  if (cause instanceof Error && cause.name === 'TRPCError') {
    return cause;
  }

  const err = new TRPCError({
    code: 'INTERNAL_SERVER_ERROR',
    cause
  }); // take stack trace from cause

  if (cause instanceof Error) {
    err.stack = cause.stack;
  }

  return err;
}

function transformTRPCResponseItem(router, item) {
  if ('error' in item) {
    return { ...item,
      error: router._def.transformer.output.serialize(item.error)
    };
  }

  if (item.result.type !== 'data') {
    return item;
  }

  return { ...item,
    result: { ...item.result,
      data: router._def.transformer.output.serialize(item.result.data)
    }
  };
}
/**
 * Takes a unserialized `TRPCResponse` and serializes it with the router's transformers
 **/


function transformTRPCResponse(router, itemOrItems) {
  return Array.isArray(itemOrItems) ? itemOrItems.map(item => transformTRPCResponseItem(router, item)) : transformTRPCResponseItem(router, itemOrItems);
}

export { TRPCError as T, callProcedure as c, getErrorFromUnknown as g, transformTRPCResponse as t };
