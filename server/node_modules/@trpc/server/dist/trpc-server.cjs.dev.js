'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var resolveHTTPResponse = require('./resolveHTTPResponse-3867844c.cjs.dev.js');
var subscription = require('./subscription-b8831081.cjs.dev.js');
var transformTRPCResponse = require('./transformTRPCResponse-8248515e.cjs.dev.js');
var adapters_standalone_dist_trpcServerAdaptersStandalone = require('../adapters/standalone/dist/trpc-server-adapters-standalone.cjs.dev.js');
var nodeHTTPRequestHandler = require('./nodeHTTPRequestHandler-2cc444d8.cjs.dev.js');
var codes = require('./codes-33cef953.cjs.dev.js');
require('events');
require('http');
require('url');

resolveHTTPResponse.assertNotBrowser();

// this has been moved to separate package

/**
 * @deprecated use `createHTTPServer` from `@trpc/server/adapters/standalone`
 */
const createHttpServer = adapters_standalone_dist_trpcServerAdaptersStandalone.createHTTPServer;
/**
 * @deprecated use `createHTTPHandler` from `@trpc/server/adapters/standalone`
 */

const createHttpHandler = adapters_standalone_dist_trpcServerAdaptersStandalone.createHTTPHandler;
/**
 * @deprecated use `CreateHTTPHandlerOptions` from `@trpc/server/adapters/standalone`
 */

/**
 * @deprecated use `nodeHTTPRequestHandler` from `@trpc/server/adapters/node-http`
 */
const requestHandler = nodeHTTPRequestHandler.nodeHTTPRequestHandler;
/**
 * @deprecated use `NodeHTTPCreateContextFn` from `@trpc/server/adapters/node-http`
 */

const middlewareMarker = /*#__PURE__*/Symbol('middlewareMarker');

/**
 * Wrap a function in a safe wrapper that never throws
 * Returns a discriminated union
 */
async function wrapCallSafe(fn) {
  try {
    const data = await fn();
    return {
      ok: true,
      data
    };
  } catch (cause) {
    return {
      ok: false,
      error: cause
    };
  }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
resolveHTTPResponse.assertNotBrowser();

function getParseFn(inputParser) {
  const parser = inputParser;

  if (typeof parser === 'function') {
    // ProcedureInputParserCustomValidatorEsque
    return parser;
  }

  if (typeof parser.parseAsync === 'function') {
    // ProcedureInputParserZodEsque
    return parser.parseAsync.bind(parser);
  }

  if (typeof parser.parse === 'function') {
    // ProcedureInputParserZodEsque
    return parser.parse.bind(parser);
  }

  if (typeof parser.validateSync === 'function') {
    // ProcedureInputParserYupEsque
    return parser.validateSync.bind(parser);
  }

  if (typeof parser.create === 'function') {
    // ProcedureInputParserSuperstructEsque
    return parser.create.bind(parser);
  }

  throw new Error('Could not find a validator fn');
}
/**
 * @internal
 */


class Procedure {
  constructor(opts) {
    this.middlewares = void 0;
    this.resolver = void 0;
    this.inputParser = void 0;
    this.parse = void 0;
    this.middlewares = opts.middlewares;
    this.resolver = opts.resolver;
    this.inputParser = opts.inputParser;
    this.parse = getParseFn(this.inputParser);
  }

  async parseInput(rawInput) {
    try {
      return await this.parse(rawInput);
    } catch (cause) {
      throw new transformTRPCResponse.TRPCError({
        code: 'BAD_REQUEST',
        cause
      });
    }
  }
  /**
   * Trigger middlewares in order, parse raw input & call resolver
   * @internal
   */


  async call(opts) {
    // wrap the actual resolver and treat as the last "middleware"
    const middlewaresWithResolver = this.middlewares.concat([async ({
      ctx
    }) => {
      const input = await this.parseInput(opts.rawInput);
      const data = await this.resolver({ ...opts,
        ctx,
        input
      });
      return {
        marker: middlewareMarker,
        ok: true,
        data,
        ctx
      };
    }]); // create `next()` calls in resolvers

    const nextFns = middlewaresWithResolver.map((fn, index) => {
      return async nextOpts => {
        const res = await wrapCallSafe(() => fn({
          ctx: nextOpts ? nextOpts.ctx : opts.ctx,
          type: opts.type,
          path: opts.path,
          rawInput: opts.rawInput,
          next: nextFns[index + 1]
        }));

        if (res.ok) {
          return res.data;
        }

        return {
          ok: false,
          error: transformTRPCResponse.getErrorFromUnknown(res.error)
        };
      };
    }); // there's always at least one "next" since we wrap this.resolver in a middleware

    const result = await nextFns[0]();

    if (!result) {
      throw new transformTRPCResponse.TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: 'No result from middlewares - did you forget to `return next()`?'
      });
    }

    if (!result.ok) {
      // re-throw original error
      throw result.error;
    }

    return result.data;
  }
  /**
   * Create new procedure with passed middlewares
   * @param middlewares
   */


  inheritMiddlewares(middlewares) {
    const Constructor = this.constructor;
    const instance = new Constructor({
      middlewares: [...middlewares, ...this.middlewares],
      resolver: this.resolver,
      inputParser: this.inputParser
    });
    return instance;
  }

}
function createProcedure(opts) {
  const inputParser = 'input' in opts ? opts.input : input => {
    if (input != null) {
      throw new transformTRPCResponse.TRPCError({
        code: 'BAD_REQUEST',
        message: 'No input expected'
      });
    }

    return undefined;
  };
  return new Procedure({
    inputParser: inputParser,
    resolver: opts.resolve,
    middlewares: []
  });
}

/* eslint-disable @typescript-eslint/ban-types */
resolveHTTPResponse.assertNotBrowser();
/**
 * @public
 */

function getDataTransformer(transformer) {
  if ('input' in transformer) {
    return transformer;
  }

  return {
    input: transformer,
    output: transformer
  };
}
/**
 * @internal
 */


const PROCEDURE_DEFINITION_MAP = {
  query: 'queries',
  mutation: 'mutations',
  subscription: 'subscriptions'
};
/**
 * @internal
 */

function safeObject(...args) {
  return Object.assign(Object.create(null), ...args);
}

const defaultFormatter = ({
  shape
}) => {
  return shape;
};

const defaultTransformer = {
  input: {
    serialize: obj => obj,
    deserialize: obj => obj
  },
  output: {
    serialize: obj => obj,
    deserialize: obj => obj
  }
};

/**
 * @internal The type signature of this class may change without warning.
 */
class Router {
  constructor(def) {
    var _def$queries, _def$mutations, _def$subscriptions, _def$middlewares, _def$errorFormatter, _def$transformer;

    this._def = void 0;
    this._def = {
      queries: (_def$queries = def === null || def === void 0 ? void 0 : def.queries) !== null && _def$queries !== void 0 ? _def$queries : safeObject(),
      mutations: (_def$mutations = def === null || def === void 0 ? void 0 : def.mutations) !== null && _def$mutations !== void 0 ? _def$mutations : safeObject(),
      subscriptions: (_def$subscriptions = def === null || def === void 0 ? void 0 : def.subscriptions) !== null && _def$subscriptions !== void 0 ? _def$subscriptions : safeObject(),
      middlewares: (_def$middlewares = def === null || def === void 0 ? void 0 : def.middlewares) !== null && _def$middlewares !== void 0 ? _def$middlewares : [],
      errorFormatter: (_def$errorFormatter = def === null || def === void 0 ? void 0 : def.errorFormatter) !== null && _def$errorFormatter !== void 0 ? _def$errorFormatter : defaultFormatter,
      transformer: (_def$transformer = def === null || def === void 0 ? void 0 : def.transformer) !== null && _def$transformer !== void 0 ? _def$transformer : defaultTransformer
    };
  }

  static prefixProcedures(procedures, prefix) {
    const eps = safeObject();

    for (const key in procedures) {
      eps[prefix + key] = procedures[key];
    }

    return eps;
  }

  query(path, procedure) {
    const router = new Router({
      queries: safeObject({
        [path]: createProcedure(procedure)
      })
    });
    return this.merge(router);
  }

  mutation(path, procedure) {
    const router = new Router({
      mutations: safeObject({
        [path]: createProcedure(procedure)
      })
    });
    return this.merge(router);
  }
  /**
   * @beta Might change without a major version bump
   */


  subscription(path, procedure) {
    const router = new Router({
      subscriptions: safeObject({
        [path]: createProcedure(procedure)
      })
    });
    return this.merge(router);
  }
  /**
   * Merge router with other router
   * @param router
   */


  merge(prefixOrRouter, maybeRouter) {
    let prefix = '';
    let childRouter;

    if (typeof prefixOrRouter === 'string' && maybeRouter instanceof Router) {
      prefix = prefixOrRouter;
      childRouter = maybeRouter;
    } else if (prefixOrRouter instanceof Router) {
      childRouter = prefixOrRouter;
    }
    /* istanbul ignore next */
    else {
      throw new Error('Invalid args');
    }

    const duplicateQueries = Object.keys(childRouter._def.queries).filter(key => !!this._def['queries'][prefix + key]);
    const duplicateMutations = Object.keys(childRouter._def.mutations).filter(key => !!this._def['mutations'][prefix + key]);
    const duplicateSubscriptions = Object.keys(childRouter._def.subscriptions).filter(key => !!this._def['subscriptions'][prefix + key]);
    const duplicates = [...duplicateQueries, ...duplicateMutations, ...duplicateSubscriptions];

    if (duplicates.length) {
      throw new Error(`Duplicate endpoint(s): ${duplicates.join(', ')}`);
    }

    const mergeProcedures = defs => {
      const newDefs = safeObject();

      for (const key in defs) {
        const procedure = defs[key];
        const newProcedure = procedure.inheritMiddlewares(this._def.middlewares);
        newDefs[key] = newProcedure;
      }

      return Router.prefixProcedures(newDefs, prefix);
    };

    return new Router({ ...this._def,
      queries: safeObject(this._def.queries, mergeProcedures(childRouter._def.queries)),
      mutations: safeObject(this._def.mutations, mergeProcedures(childRouter._def.mutations)),
      subscriptions: safeObject(this._def.subscriptions, mergeProcedures(childRouter._def.subscriptions))
    });
  }
  /**
   * Invoke procedure. Only for internal use within library.
   */


  async call(opts) {
    const {
      type,
      path
    } = opts;
    const defTarget = PROCEDURE_DEFINITION_MAP[type];
    const defs = this._def[defTarget];
    const procedure = defs[path];

    if (!procedure) {
      throw new transformTRPCResponse.TRPCError({
        code: 'NOT_FOUND',
        message: `No "${type}"-procedure on path "${path}"`
      });
    }

    return procedure.call(opts);
  }

  createCaller(ctx) {
    return {
      query: (path, ...args) => {
        return this.call({
          type: 'query',
          ctx,
          path,
          rawInput: args[0]
        });
      },
      mutation: (path, ...args) => {
        return this.call({
          type: 'mutation',
          ctx,
          path,
          rawInput: args[0]
        });
      },
      subscription: (path, ...args) => {
        return this.call({
          type: 'subscription',
          ctx,
          path,
          rawInput: args[0]
        });
      }
    };
  }
  /**
   * Function to be called before any procedure is invoked
   * @link https://trpc.io/docs/middlewares
   */


  middleware(middleware) {
    return new Router({ ...this._def,
      middlewares: [...this._def.middlewares, middleware]
    });
  }
  /**
   * Format errors
   * @link https://trpc.io/docs/error-formatting
   */


  formatError(errorFormatter) {
    if (this._def.errorFormatter !== defaultFormatter) {
      throw new Error('You seem to have double `formatError()`-calls in your router tree');
    }

    return new Router({ ...this._def,
      errorFormatter: errorFormatter
    });
  }

  getErrorShape(opts) {
    const {
      path,
      error
    } = opts;
    const {
      code
    } = opts.error;
    const shape = {
      message: error.message,
      code: codes.TRPC_ERROR_CODES_BY_KEY[code],
      data: {
        code,
        httpStatus: resolveHTTPResponse.getHTTPStatusCodeFromError(error)
      }
    };

    if (process.env.NODE_ENV !== 'production' && typeof opts.error.stack === 'string') {
      shape.data.stack = opts.error.stack;
    }

    if (typeof path === 'string') {
      shape.data.path = path;
    }

    return this._def.errorFormatter({ ...opts,
      shape
    });
  }
  /**
   * Add data transformer to serialize/deserialize input args + output
   * @link https://trpc.io/docs/data-transformers
   */


  transformer(_transformer) {
    const transformer = getDataTransformer(_transformer);

    if (this._def.transformer !== defaultTransformer) {
      throw new Error('You seem to have double `transformer()`-calls in your router tree');
    }

    return new Router({ ...this._def,
      transformer
    });
  }
  /**
   * Flattens the generics of TQueries/TMutations/TSubscriptions.
   * ⚠️ Experimental - might disappear. ⚠️
   *
   * @alpha
   */


  flat() {
    return this;
  }

}
/**
 * Subclass of `VNextRouter` with `TInputContext` and `TContext` set to the same type, for backcompat.
 *
 * @deprecated
 */

class LegacyRouter extends Router {}
function router() {
  return new Router();
}

exports.assertNotBrowser = resolveHTTPResponse.assertNotBrowser;
exports.resolveHTTPResponse = resolveHTTPResponse.resolveHTTPResponse;
exports.Subscription = subscription.Subscription;
exports.subscriptionPullFactory = subscription.subscriptionPullFactory;
exports.TRPCError = transformTRPCResponse.TRPCError;
exports.LegacyRouter = LegacyRouter;
exports.Router = LegacyRouter;
exports.createHttpHandler = createHttpHandler;
exports.createHttpServer = createHttpServer;
exports.requestHandler = requestHandler;
exports.router = router;
