'use strict';

var transformTRPCResponse = require('./transformTRPCResponse-dcbf66c5.cjs.prod.js');
var codes = require('./codes-e0df67c4.cjs.prod.js');

/* istanbul ignore file */
function assertNotBrowser() {
  if (typeof window !== 'undefined' &&         "production" !== 'test' && process.env.JEST_WORKER_ID === undefined) {
    throw new Error('Imported server-only code in the browser');
  }
}

const TRPC_ERROR_CODES_BY_NUMBER = /*#__PURE__*/codes.invert(codes.TRPC_ERROR_CODES_BY_KEY);
const JSONRPC2_TO_HTTP_CODE = {
  PARSE_ERROR: 400,
  BAD_REQUEST: 400,
  NOT_FOUND: 404,
  INTERNAL_SERVER_ERROR: 500,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  TIMEOUT: 408,
  CLIENT_CLOSED_REQUEST: 499,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  METHOD_NOT_SUPPORTED: 405
};

function getStatusCodeFromKey(code) {
  var _JSONRPC2_TO_HTTP_COD;

  return (_JSONRPC2_TO_HTTP_COD = JSONRPC2_TO_HTTP_CODE[code]) !== null && _JSONRPC2_TO_HTTP_COD !== void 0 ? _JSONRPC2_TO_HTTP_COD : 500;
}

function getHTTPStatusCode(json) {
  const arr = Array.isArray(json) ? json : [json];
  const httpStatuses = new Set(arr.map(res => {
    if ('error' in res) {
      const data = res.error.data;

      if (typeof data.httpStatus === 'number') {
        return data.httpStatus;
      }

      const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];
      return getStatusCodeFromKey(code);
    }

    return 200;
  }));

  if (httpStatuses.size !== 1) {
    return 207;
  }

  const httpStatus = httpStatuses.values().next().value;
  return httpStatus;
}
function getHTTPStatusCodeFromError(error) {
  const {
    code
  } = error;
  return getStatusCodeFromKey(code);
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
const HTTP_METHOD_PROCEDURE_TYPE_MAP = {
  GET: 'query',
  POST: 'mutation',
  PATCH: 'subscription'
};

function getRawProcedureInputOrThrow(req) {
  try {
    if (req.method === 'GET') {
      if (!req.query.has('input')) {
        return undefined;
      }

      const raw = req.query.get('input');
      return JSON.parse(raw);
    }

    return typeof req.body === 'string' ? JSON.parse(req.body) : req.body;
  } catch (cause) {
    throw new transformTRPCResponse.TRPCError({
      code: 'PARSE_ERROR',
      cause
    });
  }
}

async function resolveHTTPResponse(opts) {
  var _opts$batching$enable, _opts$batching, _HTTP_METHOD_PROCEDUR;

  const {
    createContext,
    onError,
    router,
    req
  } = opts;
  const batchingEnabled = (_opts$batching$enable = (_opts$batching = opts.batching) === null || _opts$batching === void 0 ? void 0 : _opts$batching.enabled) !== null && _opts$batching$enable !== void 0 ? _opts$batching$enable : true;

  if (req.method === 'HEAD') {
    // can be used for lambda warmup
    return {
      status: 204
    };
  }

  const type = (_HTTP_METHOD_PROCEDUR = HTTP_METHOD_PROCEDURE_TYPE_MAP[req.method]) !== null && _HTTP_METHOD_PROCEDUR !== void 0 ? _HTTP_METHOD_PROCEDUR : 'unknown';
  let ctx = undefined;
  let paths = undefined;
  const isBatchCall = !!req.query.get('batch');

  function endResponse(untransformedJSON, errors) {
    var _opts$responseMeta, _opts$responseMeta2;

    let status = getHTTPStatusCode(untransformedJSON);
    const headers = {
      'Content-Type': 'application/json'
    };
    const meta = (_opts$responseMeta = (_opts$responseMeta2 = opts.responseMeta) === null || _opts$responseMeta2 === void 0 ? void 0 : _opts$responseMeta2.call(opts, {
      ctx,
      paths,
      type,
      data: Array.isArray(untransformedJSON) ? untransformedJSON : [untransformedJSON],
      errors
    })) !== null && _opts$responseMeta !== void 0 ? _opts$responseMeta : {};

    for (const [key, value] of Object.entries((_meta$headers = meta.headers) !== null && _meta$headers !== void 0 ? _meta$headers : {})) {
      var _meta$headers;

      headers[key] = value;
    }

    if (meta.status) {
      status = meta.status;
    }

    const transformedJSON = transformTRPCResponse.transformTRPCResponse(router, untransformedJSON);
    const body = JSON.stringify(transformedJSON);
    return {
      body,
      status,
      headers
    };
  }

  try {
    if (opts.error) {
      throw opts.error;
    }

    if (isBatchCall && !batchingEnabled) {
      throw new Error(`Batching is not enabled on the server`);
    }

    if (type === 'unknown' || type === 'subscription') {
      throw new transformTRPCResponse.TRPCError({
        message: `Unexpected request method ${req.method}`,
        code: 'METHOD_NOT_SUPPORTED'
      });
    }

    const rawInput = getRawProcedureInputOrThrow(req);
    paths = isBatchCall ? opts.path.split(',') : [opts.path];
    ctx = await createContext();

    const deserializeInputValue = rawValue => {
      return typeof rawValue !== 'undefined' ? router._def.transformer.input.deserialize(rawValue) : rawValue;
    };

    const getInputs = () => {
      if (!isBatchCall) {
        return {
          0: deserializeInputValue(rawInput)
        };
      }

      if (rawInput == null || typeof rawInput !== 'object' || Array.isArray(rawInput)) {
        throw new transformTRPCResponse.TRPCError({
          code: 'BAD_REQUEST',
          message: '"input" needs to be an object when doing a batch call'
        });
      }

      const input = {};

      for (const key in rawInput) {
        const k = key;
        const rawValue = rawInput[k];
        const value = deserializeInputValue(rawValue);
        input[k] = value;
      }

      return input;
    };

    const inputs = getInputs();
    const rawResults = await Promise.all(paths.map(async (path, index) => {
      const input = inputs[index];

      try {
        const output = await transformTRPCResponse.callProcedure({
          ctx,
          router,
          path,
          input,
          type
        });
        return {
          input,
          path,
          data: output
        };
      } catch (cause) {
        const error = transformTRPCResponse.getErrorFromUnknown(cause);
        onError === null || onError === void 0 ? void 0 : onError({
          error,
          path,
          input,
          ctx,
          type: type,
          req
        });
        return {
          input,
          path,
          error
        };
      }
    }));
    const errors = rawResults.flatMap(obj => obj.error ? [obj.error] : []);
    const resultEnvelopes = rawResults.map(obj => {
      const {
        path,
        input
      } = obj;

      if (obj.error) {
        const json = {
          id: null,
          error: router.getErrorShape({
            error: obj.error,
            type,
            path,
            input,
            ctx
          })
        };
        return json;
      } else {
        const json = {
          id: null,
          result: {
            type: 'data',
            data: obj.data
          }
        };
        return json;
      }
    });
    const result = isBatchCall ? resultEnvelopes : resultEnvelopes[0];
    return endResponse(result, errors);
  } catch (cause) {
    // we get here if
    // - batching is called when it's not enabled
    // - `createContext()` throws
    // - post body is too large
    // - input deserialization fails
    const error = transformTRPCResponse.getErrorFromUnknown(cause);
    const json = {
      id: null,
      error: router.getErrorShape({
        error,
        type,
        path: undefined,
        input: undefined,
        ctx
      })
    };
    onError === null || onError === void 0 ? void 0 : onError({
      error,
      path: undefined,
      input: undefined,
      ctx,
      type: type,
      req
    });
    return endResponse(json, [error]);
  }
}

exports.assertNotBrowser = assertNotBrowser;
exports.getHTTPStatusCodeFromError = getHTTPStatusCodeFromError;
exports.resolveHTTPResponse = resolveHTTPResponse;
