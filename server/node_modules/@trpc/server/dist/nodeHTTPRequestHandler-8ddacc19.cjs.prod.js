'use strict';

var url = require('url');
var resolveHTTPResponse = require('./resolveHTTPResponse-562c3d62.cjs.prod.js');
var transformTRPCResponse = require('./transformTRPCResponse-dcbf66c5.cjs.prod.js');

async function getPostBody({
  req,
  maxBodySize
}) {
  return new Promise(resolve => {
    if ('body' in req) {
      resolve({
        ok: true,
        data: req.body
      });
      return;
    }

    let body = '';
    let hasBody = false;
    req.on('data', function (data) {
      body += data;
      hasBody = true;

      if (typeof maxBodySize === 'number' && body.length > maxBodySize) {
        resolve({
          ok: false,
          error: new transformTRPCResponse.TRPCError({
            code: 'PAYLOAD_TOO_LARGE'
          })
        });
        req.socket.destroy();
      }
    });
    req.on('end', () => {
      resolve({
        ok: true,
        data: hasBody ? body : undefined
      });
    });
  });
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
resolveHTTPResponse.assertNotBrowser();
async function nodeHTTPRequestHandler(opts) {
  var _opts$teardown;

  const createContext = async function _createContext() {
    var _opts$createContext;

    return await ((_opts$createContext = opts.createContext) === null || _opts$createContext === void 0 ? void 0 : _opts$createContext.call(opts, opts));
  };

  const {
    path,
    router
  } = opts;
  const bodyResult = await getPostBody(opts);
  const query = opts.req.query ? new url.URLSearchParams(opts.req.query) : new url.URLSearchParams(opts.req.url.split('?')[1]);
  const req = {
    method: opts.req.method,
    headers: opts.req.headers,
    query,
    body: bodyResult.ok ? bodyResult.data : undefined
  };
  const result = await resolveHTTPResponse.resolveHTTPResponse({
    batching: opts.batching,
    responseMeta: opts.responseMeta,
    path,
    createContext,
    router,
    req,
    error: bodyResult.ok ? null : bodyResult.error,

    onError(o) {
      var _opts$onError;

      opts === null || opts === void 0 ? void 0 : (_opts$onError = opts.onError) === null || _opts$onError === void 0 ? void 0 : _opts$onError.call(opts, { ...o,
        req: opts.req
      });
    }

  });
  const {
    res
  } = opts;

  if ('status' in result && (!res.statusCode || res.statusCode === 200)) {
    res.statusCode = result.status;
  }

  for (const [key, value] of Object.entries((_result$headers = result.headers) !== null && _result$headers !== void 0 ? _result$headers : {})) {
    var _result$headers;

    if (typeof value === 'undefined') {
      continue;
    }

    res.setHeader(key, value);
  }

  res.end(result.body);
  await ((_opts$teardown = opts.teardown) === null || _opts$teardown === void 0 ? void 0 : _opts$teardown.call(opts));
}

exports.nodeHTTPRequestHandler = nodeHTTPRequestHandler;
